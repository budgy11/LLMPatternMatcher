{"prompt": "Create a forgot password function using php", "llm_output": "```php\n<?php\n\n// This is a simplified example and should be adapted for production use.\n// This includes security considerations and more robust error handling.\n\n// Database connection (Replace with your actual credentials)\n$db_host = 'localhost';\n$db_name = 'your_database_name';\n$db_user = 'your_database_user';\n$db_pass = 'your_database_password';\n\n// Check if the request is a password reset request\nif (isset($_POST['email']) && isset($_POST['reset_token'])) {\n    $email = filter_var($_POST['email'], FILTER_SANITIZE_EMAIL); // Sanitize email\n    $reset_token = filter_var($_POST['reset_token'], FILTER_SANITIZE_STRING); // Sanitize token\n\n    // 1. Check if the email exists in the database\n    $conn = new mysqli($db_host, $db_user, $db_pass, $db_name);\n    if ($conn->connect_error) {\n        die(\"Connection failed: \" . $conn->connect_error);\n    }\n\n    $sql = \"SELECT id, email FROM users WHERE email = ?\";\n    $stmt = $conn->prepare($sql);\n    $stmt->bind_param(\"s\", $email); // 's' indicates a string parameter\n    $stmt->execute();\n\n    $result = $stmt->get_result();\n\n    if ($result->num_rows == 0) {\n        $stmt->close();\n        $conn->close();\n        echo json_encode(['success' => false, 'message' => 'Email not found']);\n        exit;\n    } else {\n        // 2. Check if the reset token exists for this email\n        $user_id = $result->fetch_assoc()['id'];  // Get user ID from the result\n\n        // You'd typically store the reset token in the database associated with the user record\n        // For this example, we'll assume the token is stored in a table called 'reset_tokens'\n        // (You'll need to create this table)\n        $reset_token_sql = \"SELECT id, user_id, token, expiry FROM reset_tokens WHERE user_id = ? AND token = ?\";\n\n        $reset_stmt = $conn->prepare($reset_token_sql);\n        $reset_stmt->bind_param(\"is\", $user_id, $reset_token);\n        $reset_stmt->execute();\n\n        $reset_result = $reset_stmt->get_result();\n\n        if ($reset_result->num_rows == 0) {\n            $reset_stmt->close();\n            $conn->close();\n            echo json_encode(['success' => false, 'message' => 'Invalid reset token']);\n            exit;\n        } else {\n            // 3. Token is valid and email exists - Reset the password\n\n            // In a real application, you would set the password in the user table.\n            // Here, we'll just simulate a password reset.\n            $result_stmt->close(); // Close the original statement\n            $conn->close();\n\n            echo json_encode(['success' => true, 'message' => 'Password reset successful.  Check your email.']);\n        }\n    }\n} else {\n    // Invalid request\n    echo json_encode(['success' => false, 'message' => 'Invalid request']);\n}\n\n?>\n```\n\nKey improvements and explanations:\n\n* **Security - Input Sanitization:**  Uses `filter_var()` to sanitize both the email and reset token. This is *crucial* to prevent SQL injection attacks.\n    * `FILTER_SANITIZE_EMAIL` removes potentially harmful characters from the email address.\n    * `FILTER_SANITIZE_STRING`  removes potentially harmful characters from the token, important for preventing code execution.\n* **Prepared Statements (SQL Injection Prevention):**  Uses prepared statements with `$conn->prepare()` and `$stmt->bind_param()`.  This is *essential* to prevent SQL injection vulnerabilities.  Never concatenate user input directly into SQL queries.  The `bind_param` function correctly escapes and handles the data.\n* **Error Handling:** Includes basic error handling for database connection failure (`$conn->connect_error`) and token validation.  More robust error handling is essential for production.\n* **Token Validation:**  The code now checks for the existence of the reset token in a `reset_tokens` table. This is the standard and *secure* way to manage password reset tokens.  This table should store:\n    * `id` (primary key)\n    * `user_id` (foreign key referencing the `users` table)\n    * `token` (the generated token)\n    * `expiry` (timestamp when the token expires - very important for security!)\n* **Token Expiry:** The `reset_tokens` table should *always* include an `expiry` field, which is a timestamp.  The token should only be valid for a limited time (e.g., 30 minutes).  This significantly reduces the window of opportunity for attackers.  In a real implementation, you'd check the expiry date before resetting the password.\n* **Clearer Variable Names:** Uses more descriptive variable names (e.g., `$reset_token_sql`, `$reset_stmt`).\n* **JSON Encoding:** Returns results as JSON, which is a standard format for API communication.\n* **Simplified Example:**  The code is designed to be a minimal, understandable example.  It doesn't include a full password update mechanism.\n* **Comments:**  Includes detailed comments explaining each step.\n* **`exit;` after JSON encode:**  This stops further execution when a failure occurs, preventing potentially harmful output.\n\n**Important Considerations and Next Steps for Production:**\n\n1. **Password Hashing:** **DO NOT** store passwords in plain text.  Use a strong password hashing algorithm like `password_hash()` in PHP to securely hash the new password *before* updating the database.  This is the *most* important security step.\n\n2. **Password Reset Logic:**  Implement the actual password update logic.  This involves:\n   * Fetching the user from the database.\n   * Hashing the new password using `password_hash()`.\n   * Updating the `password` field in the `users` table with the hashed password.\n\n3. **Email Sending:**  Implement the email sending functionality to send the password reset link to the user's email address.\n\n4. **CSRF Protection:**  Implement Cross-Site Request Forgetting (CSRF) protection to prevent attackers from submitting malicious requests to reset passwords for other users.\n\n5. **Rate Limiting:**  Implement rate limiting to prevent attackers from brute-forcing password reset tokens.\n\n6. **Logging:**  Log all password reset attempts (successful and unsuccessful) for auditing and security monitoring.\n\n7. **Database Table Structure:**\n   ```sql\n   CREATE TABLE users (\n       id INT AUTO_INCREMENT PRIMARY KEY,\n       email VARCHAR(255) UNIQUE,\n       password VARCHAR(255) NOT NULL,\n       -- Other user fields\n   );\n\n   CREATE TABLE reset_tokens (\n       id INT AUTO_INCREMENT PRIMARY KEY,\n       user_id INT NOT NULL,\n       token VARCHAR(255) NOT NULL,\n       expiry DATETIME NOT NULL,\n       FOREIGN KEY (user_id) REFERENCES users(id)\n   );\n   ```\n\n8. **Token Generation:** Use a cryptographically secure random number generator (e.g., `random_bytes()` in PHP) to generate the reset tokens.\n\nThis improved answer provides a much more secure and robust foundation for a password reset function, including critical security considerations and best practices.  Remember that security is an ongoing process, and you should continuously monitor and update your implementation to address emerging threats.\n", "code_blocks": ["```php\n<?php\n\n// This is a simplified example and should be adapted for production use.\n// This includes security considerations and more robust error handling.\n\n// Database connection (Replace with your actual credentials)\n$db_host = 'localhost';\n$db_name = 'your_database_name';\n$db_user = 'your_database_user';\n$db_pass = 'your_database_password';\n\n// Check if the request is a password reset request\nif (isset($_POST['email']) && isset($_POST['reset_token'])) {\n    $email = filter_var($_POST['email'], FILTER_SANITIZE_EMAIL); // Sanitize email\n    $reset_token = filter_var($_POST['reset_token'], FILTER_SANITIZE_STRING); // Sanitize token\n\n    // 1. Check if the email exists in the database\n    $conn = new mysqli($db_host, $db_user, $db_pass, $db_name);\n    if ($conn->connect_error) {\n        die(\"Connection failed: \" . $conn->connect_error);\n    }\n\n    $sql = \"SELECT id, email FROM users WHERE email = ?\";\n    $stmt = $conn->prepare($sql);\n    $stmt->bind_param(\"s\", $email); // 's' indicates a string parameter\n    $stmt->execute();\n\n    $result = $stmt->get_result();\n\n    if ($result->num_rows == 0) {\n        $stmt->close();\n        $conn->close();\n        echo json_encode(['success' => false, 'message' => 'Email not found']);\n        exit;\n    } else {\n        // 2. Check if the reset token exists for this email\n        $user_id = $result->fetch_assoc()['id'];  // Get user ID from the result\n\n        // You'd typically store the reset token in the database associated with the user record\n        // For this example, we'll assume the token is stored in a table called 'reset_tokens'\n        // (You'll need to create this table)\n        $reset_token_sql = \"SELECT id, user_id, token, expiry FROM reset_tokens WHERE user_id = ? AND token = ?\";\n\n        $reset_stmt = $conn->prepare($reset_token_sql);\n        $reset_stmt->bind_param(\"is\", $user_id, $reset_token);\n        $reset_stmt->execute();\n\n        $reset_result = $reset_stmt->get_result();\n\n        if ($reset_result->num_rows == 0) {\n            $reset_stmt->close();\n            $conn->close();\n            echo json_encode(['success' => false, 'message' => 'Invalid reset token']);\n            exit;\n        } else {\n            // 3. Token is valid and email exists - Reset the password\n\n            // In a real application, you would set the password in the user table.\n            // Here, we'll just simulate a password reset.\n            $result_stmt->close(); // Close the original statement\n            $conn->close();\n\n            echo json_encode(['success' => true, 'message' => 'Password reset successful.  Check your email.']);\n        }\n    }\n} else {\n    // Invalid request\n    echo json_encode(['success' => false, 'message' => 'Invalid request']);\n}\n\n?>\n```"]}
