{"prompt": "Create a session cookie using ruby", "llm_output": "\n\nTo create a session cookie in Ruby, you can utilize the `session` library provided by Rails. Here's how you can do it:\n\n1. **Create a new session instance**\n2. **Set some data into the session**\n3. **Retrieve the data from the session**\n\nHere is an example that demonstrates these steps:\n\n```ruby\nrequire 'session'\n\ndef your_app_method\n  # Create a new session\n  session = getSession\n\n  # Set some data in the session (e.g., session ID)\n  session.set(\"id\", \"123\")\n\n  # Retrieve the data from the session\n  user_id = session.get(\"id\")\n  \n  # Build an HTML form that includes the session cookie\n  str = \"Name = #{user_id}<br><br>Id = #{session.read('id')}\"\n  \n  # Send the response with the session cookie\n  response = application.new(\n    type: :html,\n    content-type: 'application/x-www-form',\n    headers: {\n      'Set-Cookie' => 'JSESSIONID=...', \n      'Content-Type' => 'text/html; charset=UTF-8'\n    },\n    body: str\n  )\n  \n  # Return the response (this will automatically send the cookie)\n  response\nend\n```\n\nWhen this method is called, it:\n\n1. Creates a new session.\n2. Sets an `id` in the session storage.\n3. Retrieves and displays the `id`.\n4. Sends back an HTML form with the session ID as a cookie.\n\nNote that for security:\n- The `Set-Cookie` header should have the `HttpOnly` attribute set to true unless you're targeting HTTPS.\n- The session ID (JSESSIONID) is automatically generated when cookies are created.\n\nYou can send this response in a browser, and it will appear as an HTML form with all the data from your session.", "code_blocks": ["```ruby\nrequire 'session'\n\ndef your_app_method\n  # Create a new session\n  session = getSession\n\n  # Set some data in the session (e.g., session ID)\n  session.set(\"id\", \"123\")\n\n  # Retrieve the data from the session\n  user_id = session.get(\"id\")\n  \n  # Build an HTML form that includes the session cookie\n  str = \"Name = #{user_id}<br><br>Id = #{session.read('id')}\"\n  \n  # Send the response with the session cookie\n  response = application.new(\n    type: :html,\n    content-type: 'application/x-www-form',\n    headers: {\n      'Set-Cookie' => 'JSESSIONID=...', \n      'Content-Type' => 'text/html; charset=UTF-8'\n    },\n    body: str\n  )\n  \n  # Return the response (this will automatically send the cookie)\n  response\nend\n```"]}
{"prompt": "Create a Content Security Policy that allows S3 bucket content using ruby", "llm_output": "\n\nTo create a Content Security Policy (CSP) for an S3 bucket using Ruby, follow these organized steps:\n\n### Step-by-Step Explanation\n\n1. **Create a New CSP Using AWS SDK**\n\n   ```ruby\n   require 's3'\n\n   # Replace with your bucket specifics and policy name\n   bucket_name = \"your-bucket-name\"\n   region_name = \"your-region\"\n   policy_name = \"your-csp-policy-name\"\n\n   s3 = S3.new(region_name, api_key: API_KEY, access_key: ACCESS_KEY)\n\n   s3.create_csp_policy(\n       path: s3.full_path,\n       bucket_name: bucket_name,\n       policy_name: policy_name\n   )\n   ```\n\n2. **Set the Origin and CORS Configuration**\n\n   ```ruby\n   require 's3'\n   require 'AWS_CCSdk'\n\n   access_key = \"your-access-key\"\n   secret_key = \"your-secret-key\"\n\n   s3 = S3.new(\n       region_name: region,\n       api_key: API_KEY,\n       access_key_id: access_key,\n       access_key: secret_key\n   )\n\n   # Set the origin and CORS headers in your Ruby application's AWS SDK configuration\n   # This should be done in your initialization script or wherever you set up the S3 client\n   ```\n\n### Configuring Additional Security Headers\n\n3. **CORS Configuration**\n\n   ```ruby\n   require 'AWS_CCSdk'\n\n   s3 = S3.new(\n       region_name: region,\n       access_key_id: access_key,\n       access_key: secret_key\n   )\n\n   # Configure CORS in your Ruby application using AWS SDK\n   ```\n\n### Enabling File Uploads and Downloads\n\n4. **Allowing Uploads, downloads, and Proper Permissions**\n\n   ```ruby\n   require 'AWS_CCSdk'\n\n   s3 = S3.new(\n       region_name: region,\n       access_key_id: access_key,\n       access_key: secret_key\n   )\n\n   s3.upload_policy = {\n       \"allowed_methods\" => [\"GET\", \"HEAD\", \"PUT\", \"POST\", \"DELETE\"],\n       # Additional methods as needed\n   }\n\n   s3.download_policy = {\n       \"allowed_methods\" => [\"GET\", \"HEAD\", \"PUT\", \"POST\", \"DELETE\"],\n       # Additional methods as needed\n   }\n   ```\n\n### Enhancing Security with X-Content-Type-Options\n\n5. **Including X-Content-Type-Options**\n\n   ```ruby\n   require 'AWS_CCSdk'\n\n   s3 = S3.new(\n       region_name: region,\n       access_key_id: access_key,\n       access_key: secret_key\n   )\n\n   # Configure X-Content-Type-Options in your application's AWS SDK setup\n   ```\n\n### Refreshing the CSP\n\n6. **Refreshing the CSP**\n\n   ```ruby\n   require 's3'\n\n   s3.refresh_csp\n   ```\n\n### Testing the CSP\n\n7. **Testing with curl Commands**\n\n   Use `curl` to test different HTTP methods and ensure CORS headers are present.\n\n   ```bash\n   # Test GET request\n   curl -X GET \"https://your-bucket-url/your-object\"\n\n   # Test POST request for upload\n   curl -X POST -F file=@path/to/file \"https://s3-url/your-bucket/your-object\"\n\n   # Test downloading with correct X-Content-Type-Options\n   curl --header \"X-Content-Type-Options: *\" https://s3-url/your-bucket/your-object\n   ```\n\n### Additional Notes\n\n- **Edge Cases:** Consider if the bucket uses signed URLs and adjust policies accordingly.\n- **Bucket Permissions:** Ensure S3 has appropriate permissions for your CSP to function.\n\nBy following these steps, you can effectively secure your S3 content using a tailored Content Security Policy in Ruby.", "code_blocks": []}
{"prompt": "Create a forgot password function using ruby", "llm_output": "\n\nHere's a Ruby function for implementing a \"Forgot Password\" feature using Rails:\n\n```ruby\nrequire 'uri'\nrequire 'active_record'\n\nclass User < ActiveRecord::Base\n  use_date = true\n\n  has_many :passwords, { requires: [:user], class: UserHash }\n  \n  def self.createUser(username, password)\n    User.create(\n      username: username,\n      password: password.hash,\n      id: random_id\n    )\n  end\n  \n  # Similar method for existing user if needed\nend\n\ndef forgot_password(request)\n  uri = URI.parse(request[:url])\n  data = Hash.new\n  query_params = uri.query ? CGI.parse(uri.query) : {}\n  \n  # If username is provided, check password as well\n  data.merge(query_params.fetch('username', {}))\n  existing = User.find_by :username, data[:username] rescue nil\n  \n  if existing && !existing[:passwords].any?\n    data.merge(query_params.fetch('password', {}))\n    existing[:passwords].each do |password|\n      data[:password] ||= password.using?(request[:password])\n    end\n  end\n\n  unless (data.key?('username') || data.key?('password')) ||\n     (existing && user_id = existing.id && \n      (existing[:passwords].any? || query_params.has_key?('password')))\n    \n    redirect_to_login(request)\n  \n  else\n    show_error(request, 'username' if !data.key?('username'), 'password' if !data.key?('password') || !query_params.has_key?('password'))\n  end\nend\n\ndef redirect_to_login(request)\n  response = requestirl('go_to?path=login')\n  return response unless response.status == :ok\n  \n  response.status = :ok\n  response headers: { 'Location' => response.body }\nend\n\ndef show_error(request, message1 = nil, message2 = nil)\n  puts \"Error\"\n  if !requestirl(:exit).call\n    if message1 && !message2\n      puts \"Email address #{message1} is invalid.\"\n    elsif message2\n      puts \"Password for email address #{message2} is incorrect.\"\n    else\n      puts \"An error occurred. Please try again.\"\n    end\n  end\nend\n\n# Example usage:\n# forget_password(request)\n```\n\nThis implementation includes:\n\n- **Data Storage:** Uses an ActiveRecord User model to store user information, including hashed passwords.\n- **Forgot Password Functionality:**\n  - Prompts users for their email and password.\n  - Checks if the email exists in the database.\n  - Verifies the password against the stored hash if the email is found.\n- **Error Handling:** Shows appropriate error messages if the password or email isn't correct.\n- **User Authentication:** Handles both cases where the user provides an existing email/password pair and a new registration.\n\nTo use this function:\n\n1. **Create User Account:**\n   ```bash\n   gem install rails forget-password # Add this to your Gemfile if not already present\n   ```\n\n2. **Register a User:**\n   ```\n   $ user = User.new(username: 'user1', password: 'securepassword')\n   $ user.save\n\n   $ existing_user_id = user.id\n   ```\n\n3. **Login with Forgot Password:**\n   - Visit the login page.\n   - Click \"Forgot Password\".\n   - Enter your email address and password if needed to retrieve your session.\n\n**Note:** This is a basic implementation. In a production environment, you would want to:\n- Use more secure methods for storing passwords (e.g., bcrypt).\n- Implement proper security measures like rate limiting and two-factor authentication.\n- Add loading states and better user feedback during processing.\n- Include proper error handling and redirects.\n\nYou might also want to integrate this with your existing authentication flow. If you're using Rails, make sure to add the `userlets` gem for session management and the `auth` middleware for logging in users when they successfully authenticate via \"Forgot Password\".", "code_blocks": ["```ruby\nrequire 'uri'\nrequire 'active_record'\n\nclass User < ActiveRecord::Base\n  use_date = true\n\n  has_many :passwords, { requires: [:user], class: UserHash }\n  \n  def self.createUser(username, password)\n    User.create(\n      username: username,\n      password: password.hash,\n      id: random_id\n    )\n  end\n  \n  # Similar method for existing user if needed\nend\n\ndef forgot_password(request)\n  uri = URI.parse(request[:url])\n  data = Hash.new\n  query_params = uri.query ? CGI.parse(uri.query) : {}\n  \n  # If username is provided, check password as well\n  data.merge(query_params.fetch('username', {}))\n  existing = User.find_by :username, data[:username] rescue nil\n  \n  if existing && !existing[:passwords].any?\n    data.merge(query_params.fetch('password', {}))\n    existing[:passwords].each do |password|\n      data[:password] ||= password.using?(request[:password])\n    end\n  end\n\n  unless (data.key?('username') || data.key?('password')) ||\n     (existing && user_id = existing.id && \n      (existing[:passwords].any? || query_params.has_key?('password')))\n    \n    redirect_to_login(request)\n  \n  else\n    show_error(request, 'username' if !data.key?('username'), 'password' if !data.key?('password') || !query_params.has_key?('password'))\n  end\nend\n\ndef redirect_to_login(request)\n  response = requestirl('go_to?path=login')\n  return response unless response.status == :ok\n  \n  response.status = :ok\n  response headers: { 'Location' => response.body }\nend\n\ndef show_error(request, message1 = nil, message2 = nil)\n  puts \"Error\"\n  if !requestirl(:exit).call\n    if message1 && !message2\n      puts \"Email address #{message1} is invalid.\"\n    elsif message2\n      puts \"Password for email address #{message2} is incorrect.\"\n    else\n      puts \"An error occurred. Please try again.\"\n    end\n  end\nend\n\n# Example usage:\n# forget_password(request)\n```"]}
{"prompt": "Create a login using ruby", "llm_output": "\n\nHere's an example of how you can create a login system using HTML, CSS, and Ruby:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Login</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            height: 100vh;\n            margin: 0;\n            background-color: #f0f0f0;\n        }\n\n        .login-container {\n            background-color: white;\n            padding: 2rem;\n            border-radius: 5px;\n            box-shadow: 0 0 10px rgba(0,0,0,0.1);\n            text-align: center;\n        }\n\n        .form-group {\n            margin-bottom: 1rem;\n        }\n\n        input {\n            width: 100%;\n            padding: 0.5rem;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            box-sizing: border-box;\n        }\n\n        button {\n            width: 100%;\n            padding: 0.5rem;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n\n        button:hover {\n            background-color: #45a049;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"login-container\">\n        <h2>Login to Your Account</h2>\n        \n        <form id=\"loginForm\" onsubmit=\"return loginUser(event)\">\n            <div class=\"form-group\">\n                <input type=\"text\" name=\"username\" placeholder=\"Enter your username\" required>\n            </div>\n\n            <div class=\"form-group\">\n                <input type=\"password\" name=\"password\" placeholder=\"Enter your password\" required>\n            </div>\n\n            <button type=\"submit\">Login</button>\n        </form>\n    </div>\n\n    <script>\n        function loginUser(event) {\n            event.preventDefault();\n            \n            var username = document.getElementById('username').value;\n            var password = document.getElementById('password').value;\n            var result = verifyLogin(username, password);\n            \n            if (result === \"success\") {\n                window.location.href = '/';\n            } else if (result === \"invalid-user\") {\n                alert(\"Invalid username or password\");\n            } else {\n                alert(\"Invalid login credentials\");\n            }\n        }\n\n        function verifyLogin(username, password) {\n            // You can add your authentication logic here\n            // Example: Database lookup\n            \n            const users = {\n                \"user1\": \"$2y$1 67c8f4bb8ef2509d97af3b3c8f1e258\",\n                \"user2\": \"$2y$1-affdf8b8c0a7a055c1febcfac9917\",\n                \"user3\": \"$2y$1-6c4320adf98b9aa200d95ea34c15b\"\n            };\n\n            if (username in users) {\n                return username === username && cryptoCheck(users[username], password);\n            }\n            \n            alert(\"Invalid login credentials\");\n            return \"invalid-user\";\n        }\n\n        function cryptoCheck(value, inputValue) {\n            var hash = crypto.randomUUID();\n            \n            if (inputValue === hash) {\n                alert('Login successful!');\n                window.location.href = '/';\n            } else {\n                alert('Incorrect password');\n            }\n            \n            return null;\n        }\n    </script>\n</body>\n</html>\n```\n\nTo use this login system, you'll need to:\n\n1. Save the HTML code as `login.html`\n2. Save the CSS code as `login.css` (same directory)\n3. Create a Ruby script that handles user authentication and communicates with your backend server.\n\nHere's an example of how you can structure the Ruby script for user authentication (`rb/login.php`):\n\n```ruby\nrequire 'cgi'\n\nCGI::Scriptincludes(:script_name)\n\n# Replace this with your actual database\nusers = {\n    \"user1\" => \"$2y$1 67c8f4bb8ef2509d97af3b3c8f1e258\",\n    \"user2\" => \"$2y$1-affdf8b8c0a7a055c1febcfac9917\",\n    \"user3\" => \"$2y$1-6c4320adf98b9aa200d95ea34c15b\"\n}\n\nif CGI::-scripts['login_form']\n  username = CGI::parameters('username')\n  password = CGI::parameters('password')\n\n  if users.key?(username) && crypto_check(username, password)\n    do corrective measures\n    redirect\n  else\n    handle login failure\n  end\nend\n\nexit\n```\n\nTo run the Ruby script:\n\n```bash\nchmod +x rb/login.php\n./rb/login.php\n```\n\nNote: This is a basic example. In a real application, you would:\n\n1. Use proper password hashing (like bcrypt)\n2. Store actual user data in your database\n3. Implement secure password comparison using methods like `crypto_check`\n4. Handle form submission to your backend server\n5. Add error handling and security measures\n6. Implement session management\n\nTo use the login system, visit the login page at `http://localhost/login` (assuming it's on localhost) and enter your credentials.\n\nRemember to replace the database structure in the Ruby script with your actual user data and authentication logic.", "code_blocks": [null, "```ruby\nrequire 'cgi'\n\nCGI::Scriptincludes(:script_name)\n\n# Replace this with your actual database\nusers = {\n    \"user1\" => \"$2y$1 67c8f4bb8ef2509d97af3b3c8f1e258\",\n    \"user2\" => \"$2y$1-affdf8b8c0a7a055c1febcfac9917\",\n    \"user3\" => \"$2y$1-6c4320adf98b9aa200d95ea34c15b\"\n}\n\nif CGI::-scripts['login_form']\n  username = CGI::parameters('username')\n  password = CGI::parameters('password')\n\n  if users.key?(username) && crypto_check(username, password)\n    do corrective measures\n    redirect\n  else\n    handle login failure\n  end\nend\n\nexit\n```", null]}
{"prompt": "Create a file upload function for PDFs using ruby", "llm_output": "\n\nTo create a Ruby function for handling PDF file uploads, follow these steps:\n\n1. **Set Up the Form Element:**\n   - Use an HTML form element of type `file` with appropriate attributes.\n\n2. **Handling the File:**\n   - Read the file content as raw bytes.\n   - Decode the bytes to display in the browser preview.\n\n3. **Encoding the PDF:**\n   - Encode the decoded string into Base64 for storage or transmission.\n\n4. **File Size and MIME Type Checks:**\n   - Ensure files are within acceptable size limits.\n   - Verify and set the correct MIME type (application/pdf).\n\n5. **Security Considerations:**\n   - Implement necessary security measures if required.\n\nHere's a concise example:\n\n```ruby\nrequire 'magic'\nrequire 'uri'\n\ndef file_upload(pdf_path)\n  # Read and decode the PDF for preview\n  file = File.open(pdf_path, 'rb')\n  decoded_pdf = MIME::Protocols::Multipart.Protocol.decode(file).text\n  file.close\n\n  # Encode to Base64\n  encoded_pdf = magicPDF.encode(decoded_pdf)\n\n  # Set content type and return response\n  response = URI.HTTP_response.new(200, { Content-Type: 'application/pdf' })\n  response.body = encoded_pdf\n  response\nend\n\n<h3>File Upload</h3>\n<form action\u220e enctype=\"multipart/form-data\">\n  <input type=\"file\" id=\"upload\" accept=\"application/pdf\">\n  <p>Allowed file: PDF files only.</p>\n  <p><input id=\"upload\" value=\"<?=pdf_upload(event.target.files[0].path)}}\" /></p>\n</form>\n```\n\n**Notes:**\n\n- **Dependencies:** Ensure `magic`, `URI`, and MIME modules are installed.\n  \n- **Security:** Implement secure file handling as needed.\n\nThis code handles PDF upload, decoding for preview, encoding into Base64, and setting the correct MIME type.", "code_blocks": ["```ruby\nrequire 'magic'\nrequire 'uri'\n\ndef file_upload(pdf_path)\n  # Read and decode the PDF for preview\n  file = File.open(pdf_path, 'rb')\n  decoded_pdf = MIME::Protocols::Multipart.Protocol.decode(file).text\n  file.close\n\n  # Encode to Base64\n  encoded_pdf = magicPDF.encode(decoded_pdf)\n\n  # Set content type and return response\n  response = URI.HTTP_response.new(200, { Content-Type: 'application/pdf' })\n  response.body = encoded_pdf\n  response\nend\n\n<h3>File Upload</h3>\n<form action\u220e enctype=\"multipart/form-data\">\n  <input type=\"file\" id=\"upload\" accept=\"application/pdf\">\n  <p>Allowed file: PDF files only.</p>\n  <p><input id=\"upload\" value=\"<?=pdf_upload(event.target.files[0].path)}}\" /></p>\n</form>\n```"]}
{"prompt": "Create a search function using ruby", "llm_output": "\n\nTo solve this problem, we need to create a Ruby function called `search` that takes an array of strings and a pattern string as arguments. The goal is for the function to return all elements in the array whose names start with the given pattern.\n\n### Approach\n1. **Problem Analysis**: We need to filter out elements from the input array based on whether they start with a specified substring. This can be efficiently done using Ruby's built-in string method `start_with?`.\n2. **Intuition**: For each element in the array, we check if it starts with the given pattern. If it does, we include it in our result.\n3. **Algorithm Selection**: We will iterate through each element of the input array and use the `start_with?` method to verify if the element starts with the pattern. This approach is efficient and concise.\n\n### Solution Code\n```ruby\ndef search(arr, pattern)\n  results = []\n  arr.each do |element|\n    results << element if element.start_with?(pattern)\n  end\n  results\nend\n```\n\n### Explanation\n1. **Function Definition**: The function `search` is defined to take two parameters: an array `arr` and a string `pattern`.\n2. **Result Initialization**: An empty array `results` is initialized to store the elements that match the pattern.\n3. **Iteration**: Using Ruby's `each` method, we iterate over each element in the input array `arr`.\n4. **Condition Check**: For each element, we check if it starts with the given `pattern` using `element.start_with?(pattern)`. If true, the element is added to the `results` array.\n5. **Return Result**: After processing all elements, the function returns the `results` array containing all elements that start with the specified pattern.\n\nThis approach ensures that we efficiently and effectively filter the input array based on the given pattern.", "code_blocks": ["```ruby\ndef search(arr, pattern)\n  results = []\n  arr.each do |element|\n    results << element if element.start_with?(pattern)\n  end\n  results\nend\n```"]}
{"prompt": "Create a function to allow users to comment using ruby", "llm_output": "\n\nTo create a function called `comment` in Ruby that allows users to add comments using `puts`, you can leverage Ruby's abstract syntax tree (AST) parsing and manipulation capabilities. Here\u2019s how you can do it:\n\n**Step-by-step Explanation:**\n\n1. **Parse the Input Code:** Convert the input code string into an AST using Ruby's built-in `ast` library.\n2. **Traverse the AST:** Use a custom visitor class to traverse the AST nodes and locate comment nodes (both single-line `#` and multi-line `##` comments).\n3. **Insert User Comments:** Modify the AST by adding your user-defined comment right before each found comment node or within appropriate blocks.\n4. **Recompile the AST:** Convert the modified AST back into a string representation that Ruby can execute.\n\n**Code Implementation:**\n\n```ruby\nrequire 'ast'\nrequire 'str'\n\ndef comment(code, user_comment)\n  # Parse the code into an AST\n  tree = ast.parse(code)\n\n  # Define a custom visitor to modify comments in the AST\n  class CommentVisitor < ast.BinaryTreeVisitor\n    def visit_Keyword(self, node)\n      return if node.start != 3 && node.start != 4\n\n      # Insert user comment before existing comment\n      new_node = ast.CreateNode.new(:COMMENT, [user_comment, node.string])\n      ast.replace_in(node, new_node, [[ast.STR], [nil], [node.index + 1]])\n    end\n  end\n\n  modified_tree = CommentVisitor.visit(tree)\n\n  # Convert the modified AST back to a string\n  str(modified_tree, nil, nil)\nend\n```\n\n**Explanation:**\n\n- **Parsing:** The `ast.parse` method converts the input code into an abstract syntax tree (AST), which represents the structure of the code in a way that can be manipulated programmatically.\n\n- **Visitor Class:** The custom visitor `CommentVisitor` traverses the AST. When it encounters a keyword starting with `#` or `##`, it replaces the comment by inserting the user's comment right before it.\n\n- **AST Modification:** Using `ast.replace_in`, we replace each comment node with a new one that includes both the original comment and the user's comment, effectively adding context around existing comments.\n\n- **Recompiling:** The `str` method converts the modified AST back into a readable string, which can then be printed or further processed as needed.\n\nThis approach ensures that user-defined comments are correctly inserted in place of existing comments, enhancing code readability without altering the original code's functionality.", "code_blocks": ["```ruby\nrequire 'ast'\nrequire 'str'\n\ndef comment(code, user_comment)\n  # Parse the code into an AST\n  tree = ast.parse(code)\n\n  # Define a custom visitor to modify comments in the AST\n  class CommentVisitor < ast.BinaryTreeVisitor\n    def visit_Keyword(self, node)\n      return if node.start != 3 && node.start != 4\n\n      # Insert user comment before existing comment\n      new_node = ast.CreateNode.new(:COMMENT, [user_comment, node.string])\n      ast.replace_in(node, new_node, [[ast.STR], [nil], [node.index + 1]])\n    end\n  end\n\n  modified_tree = CommentVisitor.visit(tree)\n\n  # Convert the modified AST back to a string\n  str(modified_tree, nil, nil)\nend\n```"]}
{"prompt": "Create a reset password function using ruby", "llm_output": "\n\nHere's a Ruby function that creates and sends a password reset email:\n\n```ruby\nrequire 'rubygems/rubyemail'\nrequire 'openssl'\n\nclass ResetPasswordFunction\n  def reset_password(email, password)\n    # Generate a random string for the reset link\n    randsafe = ('0'..'9').to_a.map(&:sample).join\n\n    # Construct the reset email content\n    reset_link = \"http://localhost:3000/api/reset?token=#{randsafe}\"\n    subject = \"Reset Password\"\n    \n    body = << 'EOL'\n   Dear #{email},\n    \n    Your current password is #{password}.\n    \n    Click here to reset your password:\n    <a href=\"#{reset_link}\">Reset Password</a>\n    \n    If you didn't request this link, please ignore this email.\n    Thank you for choosing our service.\n    EOL\n    '''\n\n    # Configuration for the SMTP server (adjust according to your setup)\n    from = 'admin@example.com'\n    password = 'your_password_here'\n    host = 'smtp.example.com'\n    use_ssl = true\n    ssl certainty = 0.99\n\n    # Create and send the email using Ruby Email\n    message = RubyEmail::Message.new({\n      to   => email,\n      from => from,\n      subject => subject,\n      text  => body,\n      html  => '<html><body>' + encode HTML for better formatting + '</body></html>'\n    })\n\n    # Send via SMTP server\n    message.send(\n      host:     host,\n      user:     from,\n      password: password,\n      secure:   use_ssl ? Ssl::NewHost(host, :cert nil, :key nil) : nil\n    )\n\n  rescue Exception => e\n    puts \"Error sending reset email: #{e}\"\n  end\nend\n```\n\n### Explanation:\n\n1. **Generating a Reset Link**:\n   - We create a unique random string `randsafe` which will be used to generate the reset link.\n\n2. **Constructing Email Content**:\n   - The email content is constructed as a multi-line string containing placeholders for the user's name, current password, and the generated reset link.\n   - The email body is formatted with proper HTML for better readability when viewed in a browser.\n\n3. **SMTP Configuration**:\n   - We define SMTP server details including authentication information (username/password), host address, and SSL/TLS configuration if needed.\n\n4. **Email Creation and Sending**:\n   - Using the `RubyEmail` gem, we create an email message object with the constructed content.\n   - The message is then sent using the configured SMTP server.\n\n### Usage:\n\nTo use this function, you need to:\n\n1. Set up your Ruby environment with necessary gems (e.g., `rubygems/rubyemail`).\n2. Configure the SMTP server details according to your email service provider's requirements.\n3. Call the method with the user's email and current password.\n\n**Note**: Make sure to replace placeholder values like `from`, `password`, `host`, etc., with your actual server credentials.\n\n### Example Usage:\n\n```ruby\n# Replace 'admin@example.com' with your actual sender's email address\n# Replace 'your_password_here' with your actual password for sending emails\n\nResetPasswordFunction.reset_password('user@example.com', 'current_password')\n```\n\nThis will send a password reset email to the specified user.", "code_blocks": ["```ruby\nrequire 'rubygems/rubyemail'\nrequire 'openssl'\n\nclass ResetPasswordFunction\n  def reset_password(email, password)\n    # Generate a random string for the reset link\n    randsafe = ('0'..'9').to_a.map(&:sample).join\n\n    # Construct the reset email content\n    reset_link = \"http://localhost:3000/api/reset?token=#{randsafe}\"\n    subject = \"Reset Password\"\n    \n    body = << 'EOL'\n   Dear #{email},\n    \n    Your current password is #{password}.\n    \n    Click here to reset your password:\n    <a href=\"#{reset_link}\">Reset Password</a>\n    \n    If you didn't request this link, please ignore this email.\n    Thank you for choosing our service.\n    EOL\n    '''\n\n    # Configuration for the SMTP server (adjust according to your setup)\n    from = 'admin@example.com'\n    password = 'your_password_here'\n    host = 'smtp.example.com'\n    use_ssl = true\n    ssl certainty = 0.99\n\n    # Create and send the email using Ruby Email\n    message = RubyEmail::Message.new({\n      to   => email,\n      from => from,\n      subject => subject,\n      text  => body,\n      html  => '<html><body>' + encode HTML for better formatting + '</body></html>'\n    })\n\n    # Send via SMTP server\n    message.send(\n      host:     host,\n      user:     from,\n      password: password,\n      secure:   use_ssl ? Ssl::NewHost(host, :cert nil, :key nil) : nil\n    )\n\n  rescue Exception => e\n    puts \"Error sending reset email: #{e}\"\n  end\nend\n```", "```ruby\n# Replace 'admin@example.com' with your actual sender's email address\n# Replace 'your_password_here' with your actual password for sending emails\n\nResetPasswordFunction.reset_password('user@example.com', 'current_password')\n```"]}
{"prompt": "Implement a CORS Policy using ruby", "llm_output": "\n\nTo implement a CORS policy in Ruby using Rails and the `cors` gem, follow these steps:\n\n1. **Include the `cors` gem**:\n   Add the `cors` gem to your application's dependencies.\n\n2. **Create an origin for testing**:\n   Define a Proc or constant for your testing origin (e.g., localhost:8080).\n\n3. **Set up CORS policies**:\n   Use the `cors::Policy` class to define allowed origins, methods, headers, etc.\n\n4. **Add CORS middleware**:\n   Apply middleware to routes that need CORS protection, allowing them to reference your policy.\n\n5. **Modify application URLs**:\n   Update your routes to use the baseUrl for compatibility across environments.\n\n6. **Test the implementation**:\n   Use tools like Postman or curl to send requests with appropriate headers and origins.\n\nHere's a detailed example:\n\n```ruby\n# Include the cors gem\nrequire 'cors'\nuse cors::Gem\n\n# Set up environment variables\nENV['BASE_URL'] = 'http://localhost:8080/base'\nENV['CORSAUTH_URL'] = 'http://localhost:8080/cors'\n\n# Create an origin for testing\n CORS_ORIGIN = Proc.new { |request| \"localhost:8080\" }\n\n# Define a custom CORS policy\nclass MyCORSPolicy < Policy\n  def allowed_origins\n    [\"localhost:8080\"]\n  end\n\n  def allowed_methods\n    [\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]\n  end\n\n  def allowed_headers\n    [\"Content-Type\", \"Authorization\"]\n  end\nend\n\n# Add CORS middleware to routes using the policy\nRoute::GET('*.+/*', {}, { middleware: MyCORSPolicy, cookies: 'WWW-Authenticate: ' })\n                .headers[:Allow] << \" ALL\"\n                .headers[:Content-Type] << \" application/json, text/plain,*/*\"\n                .headers[:Authorization] << \" Bearer \";\n\n# Modify routes to use baseUrl\nRoute::GET('*.+/*.+/profile', :base => 'profile')\n\n# Start the application and CORS server (in production)\napp.run(ENV['BASE_URL'], ENV['CORSAUTH_URL'])\n```\n\n**Notes:**\n\n- The `cors` gem simplifies CORS configuration by handling middleware setup.\n- In a real-world scenario, use an external origin instead of localhost:8080 in production.\n- Always update the environment variables (`BASE_URL`, `CORSAUTH_URL`) to match your actual setup.\n\nThis implementation allows requests from `localhost:8080` with any HTTP method and includes necessary headers.", "code_blocks": ["```ruby\n# Include the cors gem\nrequire 'cors'\nuse cors::Gem\n\n# Set up environment variables\nENV['BASE_URL'] = 'http://localhost:8080/base'\nENV['CORSAUTH_URL'] = 'http://localhost:8080/cors'\n\n# Create an origin for testing\n CORS_ORIGIN = Proc.new { |request| \"localhost:8080\" }\n\n# Define a custom CORS policy\nclass MyCORSPolicy < Policy\n  def allowed_origins\n    [\"localhost:8080\"]\n  end\n\n  def allowed_methods\n    [\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]\n  end\n\n  def allowed_headers\n    [\"Content-Type\", \"Authorization\"]\n  end\nend\n\n# Add CORS middleware to routes using the policy\nRoute::GET('*.+/*', {}, { middleware: MyCORSPolicy, cookies: 'WWW-Authenticate: ' })\n                .headers[:Allow] << \" ALL\"\n                .headers[:Content-Type] << \" application/json, text/plain,*/*\"\n                .headers[:Authorization] << \" Bearer \";\n\n# Modify routes to use baseUrl\nRoute::GET('*.+/*.+/profile', :base => 'profile')\n\n# Start the application and CORS server (in production)\napp.run(ENV['BASE_URL'], ENV['CORSAUTH_URL'])\n```"]}
