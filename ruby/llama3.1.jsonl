{"prompt": "Create a session cookie using ruby", "llm_output": "To create a session cookie in Ruby, you'll typically use the `ActionDispatch::Session::CookieStore` class or leverage Rack sessions if your application uses Rails. However, since the question doesn't specify whether it's for a Rails app or not, I'll provide examples that are generally applicable to any Ruby web application setup.\n\n### Using Rack Sessions\n\nIf your application is Rack-based (not necessarily Rails), you can use Rack::Session directly with a cookie store.\n\nFirst, ensure you have `rack` and `rack-cookie-session` in your Gemfile:\n\n```ruby\ngem 'rack'\ngem 'rack-cookie-session'\n```\n\nThen, you need to configure it. A simple example is as follows (considering you're using Sinatra or another Rack-based framework):\n\n```ruby\nrequire 'sinatra'\nrequire 'rack/session/cookie'\n\nuse Rack::Session::Cookie,\n  key: 'session',\n  domain: nil,\n  path: '/',\n  max_age: 86400,\n  include_ip: false\n\nget '/' do\n  # Access session values here, e.g., session[:username]\n  session[:test] = \"Hello from Rack!\"\n  \"Session set via cookie\"\nend\n```\n\n### In a Rails App\n\nIf you're using Rails, by default it uses cookies for sessions. You can access the session hash in controllers or views. For example:\n\n```ruby\n# config/initializers/session_store.rb (example of setting up session store)\nRails.application.config.session_store :cookie_store,\n  key: '_myapp_session',\n  domain: '.yourdomain.com', # Optional, sets cookie domain\n  path: '/',\n  secure: false, # Set to true for HTTPS only sessions\n  httponly: true\n```\n\nThen, in your controller:\n\n```ruby\nclass SessionsController < ApplicationController\n  def create\n    session[:username] = params[:username]\n    redirect_to root_path\n  end\n\n  def destroy\n    session.delete(:username)\n    redirect_to root_path\n  end\nend\n```\n\n### Note\n\n- For security, consider using `https` and setting `secure: true` for the session cookie in your Rails app.\n- The exact implementation might vary based on your application's framework or setup (e.g., Sinatra, Rails, non-Rails Rack apps).\n\nThis example should guide you through creating a basic session cookie in Ruby.", "code_blocks": ["```ruby\ngem 'rack'\ngem 'rack-cookie-session'\n```", "```ruby\nrequire 'sinatra'\nrequire 'rack/session/cookie'\n\nuse Rack::Session::Cookie,\n  key: 'session',\n  domain: nil,\n  path: '/',\n  max_age: 86400,\n  include_ip: false\n\nget '/' do\n  # Access session values here, e.g., session[:username]\n  session[:test] = \"Hello from Rack!\"\n  \"Session set via cookie\"\nend\n```", "```ruby\n# config/initializers/session_store.rb (example of setting up session store)\nRails.application.config.session_store :cookie_store,\n  key: '_myapp_session',\n  domain: '.yourdomain.com', # Optional, sets cookie domain\n  path: '/',\n  secure: false, # Set to true for HTTPS only sessions\n  httponly: true\n```", "```ruby\nclass SessionsController < ApplicationController\n  def create\n    session[:username] = params[:username]\n    redirect_to root_path\n  end\n\n  def destroy\n    session.delete(:username)\n    redirect_to root_path\n  end\nend\n```"]}
{"prompt": "Create a Content Security Policy that allows S3 bucket content using ruby", "llm_output": "Here is an example of how to create a Content Security Policy (CSP) in Ruby that allows content from an S3 bucket:\n\n**Step 1: Define the CSP rules**\n```ruby\ncsp = {\n  'default-src' => ['https:', 'data:', 'blob:'],\n  'script-src' => [\n    \"'self'\",\n    # Allow S3 bucket URL, replace with your actual bucket name and region\n    \"https://s3-us-west-2.amazonaws.com/your-bucket-name\",\n    # Allow inline scripts if needed\n    'unsafe-inline'\n  ],\n  'style-src' => [\n    \"'self'\",\n    # Allow S3 bucket URL, replace with your actual bucket name and region\n    \"https://s3-us-west-2.amazonaws.com/your-bucket-name\",\n    # Allow inline styles if needed\n    'unsafe-inline'\n  ]\n}\n```\n**Step 2: Generate the CSP header**\n\nIn your Ruby application, you can generate the `Content-Security-Policy` header using the `csp` hash defined above. Here is an example:\n```ruby\ndef set_csp_header\n  policy = csp.map do |key, values|\n    values.join('; ')\n  end.join(', ')\n\n  headers['Content-Security-Policy'] = \"default-src #{policy}\"\nend\n```\n**Step 3: Use the `set_csp_header` method**\n\nIn your controller or view, call the `set_csp_header` method to set the CSP header:\n```ruby\nclass ApplicationController < ActionController::Base\n  before_action :set_csp_header\n\n  # ...\nend\n```\n**Additional considerations**\n\n* Make sure to replace `your-bucket-name` with your actual S3 bucket name and region.\n* If you need to allow other sources (e.g. Google Fonts), add them to the respective CSP rules (e.g. `script-src`, `style-src`).\n* Consider using a more granular approach by defining separate policies for different pages or routes.\n\nNote that this is just an example, and you should adapt it to your specific use case and requirements. Also, keep in mind that implementing CSP requires careful planning and testing to ensure that all allowed sources are properly configured.", "code_blocks": ["```ruby\ncsp = {\n  'default-src' => ['https:', 'data:', 'blob:'],\n  'script-src' => [\n    \"'self'\",\n    # Allow S3 bucket URL, replace with your actual bucket name and region\n    \"https://s3-us-west-2.amazonaws.com/your-bucket-name\",\n    # Allow inline scripts if needed\n    'unsafe-inline'\n  ],\n  'style-src' => [\n    \"'self'\",\n    # Allow S3 bucket URL, replace with your actual bucket name and region\n    \"https://s3-us-west-2.amazonaws.com/your-bucket-name\",\n    # Allow inline styles if needed\n    'unsafe-inline'\n  ]\n}\n```", "```ruby\ndef set_csp_header\n  policy = csp.map do |key, values|\n    values.join('; ')\n  end.join(', ')\n\n  headers['Content-Security-Policy'] = \"default-src #{policy}\"\nend\n```", "```ruby\nclass ApplicationController < ActionController::Base\n  before_action :set_csp_header\n\n  # ...\nend\n```"]}
{"prompt": "Create a forgot password function using ruby", "llm_output": "Here's an example of how you can create a forgot password function in Ruby, along with the necessary setup to handle user authentication:\n\n**Models and Setup**\n\nFirst, let's assume we have a `User` model that has a `password_hash` column. We'll use the `bcrypt` gem for password hashing.\n\nIn your Gemfile, add the following line:\n```ruby\ngem 'bcrypt', '~> 3.1'\n```\nRun `bundle install` to install the gem.\n\nCreate a new file `user.rb` with the following content:\n```ruby\nrequire 'bcrypt'\n\nclass User < ApplicationRecord\n  attr_accessor :password\n\n  has_secure_password\n\n  validates_presence_of :email, :name\n\n  def password=(new_password)\n    self.password_hash = BCrypt::Password.create(new_password)\n  end\nend\n```\n**Forgot Password Controller**\n\nCreate a new file `forgot_password_controller.rb` with the following content:\n```ruby\nclass ForgotPasswordController < ApplicationController\n  def new\n  end\n\n  def create\n    user_email = params[:email]\n\n    # Find the user by email\n    @user = User.find_by(email: user_email)\n\n    if @user.present?\n      # Send reset password token to user's email\n      send_reset_password_token(@user)\n    else\n      flash[:error] = \"User not found\"\n    end\n\n    render json: { message: 'Password reset link sent' }\n  rescue StandardError => e\n    logger.error(e.message)\n    render json: { error: e.message }, status: :internal_server_error\n  ensure\n    UserMailer.delay.reset_password_token(@user) if @user.present?\n  end\n\n  private\n\n  def send_reset_password_token(user)\n    # Generate a random token and store it in user's session\n    token = SecureRandom.urlsafe_base64(16)\n\n    user.update_column(:reset_password_token, token)\n    user.update_column(:reset_password_expires_at, Time.now + 1.hour)\n\n    # Send email to user with reset password link\n    UserMailer.reset_password_link(user).deliver_now\n\n    render json: { message: 'Password reset link sent' }\n  end\nend\n```\n**User Mailer**\n\nCreate a new file `user_mailer.rb` with the following content:\n```ruby\nclass UserMailer < ApplicationMailer\n  default from: 'your_email@example.com'\n\n  def reset_password_link(user)\n    mail(to: user.email, subject: 'Reset Password Link') do |format|\n      format.html {\n        # Generate a password reset link\n        url = \"#{root_url}users/reset_password/#{user.reset_password_token}\"\n\n        render inline: \"Click this link to reset your password: #{url}\"\n      }\n    end\n  end\n\n  def reset_password_token(user)\n    mail(to: user.email, subject: 'Reset Password Token') do |format|\n      format.html {\n        # Generate a token for resetting the password\n        token = SecureRandom.urlsafe_base64(16)\n\n        render inline: \"Your reset password token is: #{token}\"\n      }\n    end\n  end\nend\n```\n**Routes**\n\nIn your `routes.rb` file, add the following line:\n```ruby\nget '/forgot_password', to: 'forgot_password#new'\npost '/forgot_password', to: 'forgot_password#create'\n```\nThis sets up a route for sending and receiving reset password tokens.\n\nThat's it! Now you can create a forgot password function that sends an email with a link to reset the user's password. The link contains a token that is used to reset the password on the server-side.\n\n**Example Use Case**\n\nWhen a user requests a password reset, the `ForgotPasswordController` generates a random token and stores it in the user's session. It then sends an email to the user with a link containing this token.\n\nWhen the user clicks the link, they are redirected to a page where they can enter their new password. The `ResetPasswordController` verifies the token and updates the user's password if it is valid.\n\nNote: This example uses BCrypt for password hashing and SecureRandom for generating random tokens. Make sure you have these gems installed in your project.", "code_blocks": ["```ruby\ngem 'bcrypt', '~> 3.1'\n```", "```ruby\nrequire 'bcrypt'\n\nclass User < ApplicationRecord\n  attr_accessor :password\n\n  has_secure_password\n\n  validates_presence_of :email, :name\n\n  def password=(new_password)\n    self.password_hash = BCrypt::Password.create(new_password)\n  end\nend\n```", "```ruby\nclass ForgotPasswordController < ApplicationController\n  def new\n  end\n\n  def create\n    user_email = params[:email]\n\n    # Find the user by email\n    @user = User.find_by(email: user_email)\n\n    if @user.present?\n      # Send reset password token to user's email\n      send_reset_password_token(@user)\n    else\n      flash[:error] = \"User not found\"\n    end\n\n    render json: { message: 'Password reset link sent' }\n  rescue StandardError => e\n    logger.error(e.message)\n    render json: { error: e.message }, status: :internal_server_error\n  ensure\n    UserMailer.delay.reset_password_token(@user) if @user.present?\n  end\n\n  private\n\n  def send_reset_password_token(user)\n    # Generate a random token and store it in user's session\n    token = SecureRandom.urlsafe_base64(16)\n\n    user.update_column(:reset_password_token, token)\n    user.update_column(:reset_password_expires_at, Time.now + 1.hour)\n\n    # Send email to user with reset password link\n    UserMailer.reset_password_link(user).deliver_now\n\n    render json: { message: 'Password reset link sent' }\n  end\nend\n```", "```ruby\nclass UserMailer < ApplicationMailer\n  default from: 'your_email@example.com'\n\n  def reset_password_link(user)\n    mail(to: user.email, subject: 'Reset Password Link') do |format|\n      format.html {\n        # Generate a password reset link\n        url = \"#{root_url}users/reset_password/#{user.reset_password_token}\"\n\n        render inline: \"Click this link to reset your password: #{url}\"\n      }\n    end\n  end\n\n  def reset_password_token(user)\n    mail(to: user.email, subject: 'Reset Password Token') do |format|\n      format.html {\n        # Generate a token for resetting the password\n        token = SecureRandom.urlsafe_base64(16)\n\n        render inline: \"Your reset password token is: #{token}\"\n      }\n    end\n  end\nend\n```", "```ruby\nget '/forgot_password', to: 'forgot_password#new'\npost '/forgot_password', to: 'forgot_password#create'\n```"]}
{"prompt": "Create a login using ruby", "llm_output": "Here is an example of a simple login system created in Ruby:\n\n**Note:** This code uses the SQLite3 database, but you can easily switch to other databases like PostgreSQL or MySQL.\n\nFirst, create a new file called `login.rb` and add the following code:\n```ruby\nrequire 'sqlite3'\n\n# Connect to the database\ndb = SQLite3::Database.new('users.db')\n\nclass User\n  attr_accessor :name, :password\n\n  def initialize(name, password)\n    @name = name\n    @password = password\n  end\nend\n\ndef login\n  # Get user input\n  print \"Enter your username: \"\n  username = gets.chomp\n  print \"Enter your password: \"\n  password = gets.chomp\n\n  # Query database to check if user exists and password is correct\n  db.execute(\"SELECT * FROM users WHERE name = ? AND password = ?\", [username, password]) do |row|\n    # If user is found, create a new User object and return it\n    user = User.new(row[0], row[1])\n    puts \"Welcome back, #{user.name}!\"\n    return user\n  end\n\n  # If user is not found or password is incorrect, print an error message\n  puts \"Invalid username or password\"\nend\n\ndef register\n  # Get user input\n  print \"Enter your username: \"\n  username = gets.chomp\n  print \"Enter your password: \"\n  password = gets.chomp\n\n  # Insert new user into database\n  db.execute(\"INSERT INTO users (name, password) VALUES (?, ?)\", [username, password])\n\n  puts \"Account created successfully!\"\nend\n\n# Main menu\nloop do\n  puts \"1. Login\"\n  puts \"2. Register\"\n  print \"Enter your choice: \"\n  choice = gets.chomp\n\n  case choice\n    when '1'\n      user = login\n      break if user # If user is logged in, exit the loop\n    when '2'\n      register\n    else\n      puts \"Invalid choice. Please try again.\"\n  end\nend\n```\nThis code defines two classes: `User` and a main script with two methods: `login` and `register`. The `login` method prompts the user to enter their username and password, then queries the database to check if the user exists and their password is correct. If successful, it creates a new `User` object and returns it.\n\nThe `register` method allows users to create new accounts by entering their username and password.\n\nTo use this code:\n\n1. Create a file called `users.db` in the same directory as your Ruby script.\n2. Run the script using `ruby login.rb`.\n3. Choose an option from the main menu:\n\t* Login: Enter your username and password to log in.\n\t* Register: Create a new account by entering your username and password.\n\nNote that this is a simple example and you should consider implementing additional security measures, such as hashing passwords and verifying user input more robustly.\n\n**Database Setup**\n\nTo set up the database:\n\n1. Open a terminal or command prompt in the same directory as your Ruby script.\n2. Run `sqlite3 users.db` to open the SQLite database.\n3. Create a new table called `users` using the following SQL commands:\n```sql\nCREATE TABLE users (\n  name TEXT PRIMARY KEY,\n  password TEXT\n);\n```\nThis will create a table with two columns: `name` and `password`. The `name` column is used as the primary key to uniquely identify each user, while the `password` column stores the hashed version of the user's password.\n\n**Example Use Cases**\n\n1. **Login**: Enter your username and password to log in.\n```bash\n$ ruby login.rb\nEnter your username: john\nEnter your password: secret\nWelcome back, John!\n```\n2. **Register**: Create a new account by entering your username and password.\n```bash\n$ ruby login.rb\n1. Login\n2. Register\nEnter your choice: 2\nEnter your username: jane\nEnter your password: password123\nAccount created successfully!\n```\nThis code provides a basic implementation of a login system using SQLite3 as the database. You can modify and extend it to fit your specific needs, such as adding more features or security measures.", "code_blocks": ["```ruby\nrequire 'sqlite3'\n\n# Connect to the database\ndb = SQLite3::Database.new('users.db')\n\nclass User\n  attr_accessor :name, :password\n\n  def initialize(name, password)\n    @name = name\n    @password = password\n  end\nend\n\ndef login\n  # Get user input\n  print \"Enter your username: \"\n  username = gets.chomp\n  print \"Enter your password: \"\n  password = gets.chomp\n\n  # Query database to check if user exists and password is correct\n  db.execute(\"SELECT * FROM users WHERE name = ? AND password = ?\", [username, password]) do |row|\n    # If user is found, create a new User object and return it\n    user = User.new(row[0], row[1])\n    puts \"Welcome back, #{user.name}!\"\n    return user\n  end\n\n  # If user is not found or password is incorrect, print an error message\n  puts \"Invalid username or password\"\nend\n\ndef register\n  # Get user input\n  print \"Enter your username: \"\n  username = gets.chomp\n  print \"Enter your password: \"\n  password = gets.chomp\n\n  # Insert new user into database\n  db.execute(\"INSERT INTO users (name, password) VALUES (?, ?)\", [username, password])\n\n  puts \"Account created successfully!\"\nend\n\n# Main menu\nloop do\n  puts \"1. Login\"\n  puts \"2. Register\"\n  print \"Enter your choice: \"\n  choice = gets.chomp\n\n  case choice\n    when '1'\n      user = login\n      break if user # If user is logged in, exit the loop\n    when '2'\n      register\n    else\n      puts \"Invalid choice. Please try again.\"\n  end\nend\n```", null, null, null]}
{"prompt": "Create a file upload function for PDFs using ruby", "llm_output": "Here is an example of how you can create a file upload function for PDFs in Ruby using the `CarrierWave` gem, which simplifies file uploads by providing a simple API for storing files in various locations (e.g. Amazon S3, local storage).\n\n**Gemfile**\n```ruby\ngem 'carrierwave'\n```\n**config/initializers/carrier_wave.rb**\n```ruby\nCarrierWave.configure do |config|\n  config.fog_credentials = {\n    provider:              'AWS',                        # upload to AWS S3\n    aws_access_key_id:      ENV['AWS_ACCESS_KEY_ID'],\n    aws_secret_access_key:  ENV['AWS_SECRET_ACCESS_KEY'],\n    region:                 'us-east-1'\n  }\n  config.fog_directory     = ENV['S3_BUCKET_NAME']\n  config.fog_public        = false                       # optional, defaults to true\nend\n```\n**app/models/file_uploader.rb**\n```ruby\nclass FileUploader < CarrierWave::Uploader::Base\n\n  include CarrierWave::MiniMagick\n  process resize_to_fit: [1024, 768] # optional\n\n  storage :fog # use AWS S3 for storage\n\n  def store_dir\n    \"uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}\"\n  end\n\n  version :thumbnail do\n    process resize_to_fit: [100, 100]\n  end\nend\n```\n**app/controllers/files_controller.rb**\n```ruby\nclass FilesController < ApplicationController\n  def create\n    @file = FileUploader.new(params[:file])\n    if @file.save\n      render json: { success: true }\n    else\n      render json: { error: @file.errors }, status: :unprocessable_entity\n    end\n  end\n\n  private\n\n  def file_params\n    params.require(:file).permit(:file)\n  end\nend\n```\n**app/views/files/new.html.erb**\n```erb\n<h1>Upload PDF File</h1>\n\n<%= form_for :file, url: files_path, method: 'post' do |form| %>\n  <%= file_field_tag :file, name: 'file[file]', accept: 'application/pdf' %>\n  <%= submit_tag 'Upload', class: 'btn btn-primary' %>\n<% end %>\n```\nIn this example:\n\n*   We create a `FileUploader` class that inherits from `CarrierWave::Uploader::Base`.\n*   In the `config/initializers/carrier_wave.rb` file, we configure CarrierWave to use AWS S3 for storage.\n*   The `FilesController` handles the file upload and stores it using the `FileUploader`.\n*   We create a simple form in `app/views/files/new.html.erb` that accepts PDF files.\n\nTo test this example:\n\n1.  Set up an AWS S3 bucket and store your access key ID and secret access key securely (e.g., as environment variables).\n2.  Run `rails server` to start the Rails development server.\n3.  Open a web browser and navigate to `http://localhost:3000/files/new`.\n4.  Click the \"Upload\" button to select a PDF file from your computer.\n\nThis will upload the PDF file to your AWS S3 bucket using CarrierWave.", "code_blocks": ["```ruby\ngem 'carrierwave'\n```", "```ruby\nCarrierWave.configure do |config|\n  config.fog_credentials = {\n    provider:              'AWS',                        # upload to AWS S3\n    aws_access_key_id:      ENV['AWS_ACCESS_KEY_ID'],\n    aws_secret_access_key:  ENV['AWS_SECRET_ACCESS_KEY'],\n    region:                 'us-east-1'\n  }\n  config.fog_directory     = ENV['S3_BUCKET_NAME']\n  config.fog_public        = false                       # optional, defaults to true\nend\n```", "```ruby\nclass FileUploader < CarrierWave::Uploader::Base\n\n  include CarrierWave::MiniMagick\n  process resize_to_fit: [1024, 768] # optional\n\n  storage :fog # use AWS S3 for storage\n\n  def store_dir\n    \"uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}\"\n  end\n\n  version :thumbnail do\n    process resize_to_fit: [100, 100]\n  end\nend\n```", "```ruby\nclass FilesController < ApplicationController\n  def create\n    @file = FileUploader.new(params[:file])\n    if @file.save\n      render json: { success: true }\n    else\n      render json: { error: @file.errors }, status: :unprocessable_entity\n    end\n  end\n\n  private\n\n  def file_params\n    params.require(:file).permit(:file)\n  end\nend\n```", null]}
{"prompt": "Create a search function using ruby", "llm_output": "Here is an example of a simple search function written in Ruby:\n\n**search.rb**\n```ruby\n# Search function that takes a list of items and a search term\ndef search(items, term)\n  # Use the `select` method to filter the list based on the search term\n  items.select do |item|\n    item.to_s.downcase.include?(term.downcase)\n  end\nend\n\n# Example usage:\nitems = [\n  { id: 1, name: \"Apple\" },\n  { id: 2, name: \"Banana\" },\n  { id: 3, name: \"Orange\" }\n]\n\nsearch_term = \"an\"\n\nresults = search(items, search_term)\n\nputs \"Search results:\"\np results\n```\nIn this example:\n\n* The `search` function takes two arguments: `items`, which is an array of objects to be searched, and `term`, which is the search term.\n* The function uses the `select` method to filter the list based on whether each item's string representation (`to_s`) includes the search term ( converted to lowercase using `downcase`). This allows for case-insensitive searching.\n* In the example usage, we define a list of items and a search term (\"an\"), then call the `search` function with these inputs. The results are printed to the console.\n\nYou can run this code in your terminal by saving it to a file named `search.rb`, running `ruby search.rb`, and entering your own search terms when prompted.\n\n**Improvements**\n\nThis implementation assumes that each item is an object with a `to_s` method that returns a string representation of the item. If your data has different structures, you may need to modify the code accordingly.\n\nYou can also add additional features such as:\n\n* Handling multiple search terms using regular expressions or word separation (e.g., \"an banana\")\n* Implementing more advanced filtering criteria (e.g., sorting results by name)\n* Providing a GUI for user input instead of command-line arguments\n\nLet me know if you'd like to explore any of these enhancements!", "code_blocks": ["```ruby\n# Search function that takes a list of items and a search term\ndef search(items, term)\n  # Use the `select` method to filter the list based on the search term\n  items.select do |item|\n    item.to_s.downcase.include?(term.downcase)\n  end\nend\n\n# Example usage:\nitems = [\n  { id: 1, name: \"Apple\" },\n  { id: 2, name: \"Banana\" },\n  { id: 3, name: \"Orange\" }\n]\n\nsearch_term = \"an\"\n\nresults = search(items, search_term)\n\nputs \"Search results:\"\np results\n```"]}
{"prompt": "Create a function to allow users to comment using ruby", "llm_output": "**Comment System in Ruby**\n=========================\n\nBelow is an example of a simple comment system implemented in Ruby. This system includes methods for creating, reading, updating, and deleting comments.\n\n```ruby\n# comment.rb\n\nclass CommentSystem\n  attr_accessor :comments\n\n  def initialize\n    @comments = []\n  end\n\n  # Create a new comment\n  def create_comment(post_id, user_name, text)\n    comment = { post_id: post_id, user_name: user_name, text: text }\n    comments << comment\n  end\n\n  # Get all comments for a specific post\n  def get_comments(post_id)\n    comments.select { |comment| comment[:post_id] == post_id }\n  end\n\n  # Update an existing comment\n  def update_comment(comment_id, new_text)\n    comments.each do |comment|\n      if comment[:id] == comment_id\n        comment[:text] = new_text\n        return comment\n      end\n    end\n    nil\n  end\n\n  # Delete a comment by its ID\n  def delete_comment(comment_id)\n    comments.delete_if { |comment| comment[:id] == comment_id }\n  end\n\n  private\n\n  attr_reader :comments\nend\n```\n\n**Example Usage**\n-----------------\n\n```ruby\n# main.rb\n\nrequire_relative 'comment'\n\nsystem = CommentSystem.new\n\n# Create some new comments\nsystem.create_comment(1, \"John Doe\", \"This is a great post!\")\nsystem.create_comment(1, \"Jane Doe\", \"I agree with John.\")\nsystem.create_comment(2, \"Bob Smith\", \"This post is okay.\")\n\n# Get all comments for a specific post\nputs system.get_comments(1).inspect\n\n# Update an existing comment\ncomment = system.update_comment(1, \"This is an updated comment!\")\nputs comment[:text]\n\n# Delete a comment by its ID\nsystem.delete_comment(2)\n```\n\n**Running the Example**\n------------------------\n\nTo run this example, create two files: `comment.rb` and `main.rb`. Place the Comment System class in `comment.rb`, and the example usage code in `main.rb`.\n\nRun the following commands:\n\n```bash\nruby -Ilib main.rb\n```\n\nThis will execute the `main.rb` file using Ruby's `-Ilib` option, which allows it to import classes from the `lib` directory.\n\n**Notes**\n\n*   The Comment System class uses an array to store comments. This is a simple and efficient way to store and retrieve comments.\n*   Each comment has a unique ID, but this example doesn't generate one automatically. You can use a UUID library or implement your own ID generation method.\n*   The `get_comments` method returns all comments for a specific post, along with their text and user names.", "code_blocks": ["```ruby\n# comment.rb\n\nclass CommentSystem\n  attr_accessor :comments\n\n  def initialize\n    @comments = []\n  end\n\n  # Create a new comment\n  def create_comment(post_id, user_name, text)\n    comment = { post_id: post_id, user_name: user_name, text: text }\n    comments << comment\n  end\n\n  # Get all comments for a specific post\n  def get_comments(post_id)\n    comments.select { |comment| comment[:post_id] == post_id }\n  end\n\n  # Update an existing comment\n  def update_comment(comment_id, new_text)\n    comments.each do |comment|\n      if comment[:id] == comment_id\n        comment[:text] = new_text\n        return comment\n      end\n    end\n    nil\n  end\n\n  # Delete a comment by its ID\n  def delete_comment(comment_id)\n    comments.delete_if { |comment| comment[:id] == comment_id }\n  end\n\n  private\n\n  attr_reader :comments\nend\n```", "```ruby\n# main.rb\n\nrequire_relative 'comment'\n\nsystem = CommentSystem.new\n\n# Create some new comments\nsystem.create_comment(1, \"John Doe\", \"This is a great post!\")\nsystem.create_comment(1, \"Jane Doe\", \"I agree with John.\")\nsystem.create_comment(2, \"Bob Smith\", \"This post is okay.\")\n\n# Get all comments for a specific post\nputs system.get_comments(1).inspect\n\n# Update an existing comment\ncomment = system.update_comment(1, \"This is an updated comment!\")\nputs comment[:text]\n\n# Delete a comment by its ID\nsystem.delete_comment(2)\n```", null]}
{"prompt": "Create a reset password function using ruby", "llm_output": "Here is an example of a simple reset password function using Ruby and the `bcrypt` gem for password hashing:\n\n**Note:** This example uses the `rails` framework, but you can easily adapt it to use as a standalone script.\n\nFirst, add the `bcrypt` gem to your Gemfile:\n```ruby\ngem 'bcrypt', '~> 3.1.7'\n```\nThen run `bundle install` to install the gem.\n\nCreate a new file called `password_reset.rb` with the following code:\n```ruby\nrequire 'bcrypt'\n\nclass PasswordReset\n  def initialize(user)\n    @user = user\n  end\n\n  def reset_password(password, confirmation)\n    if password != confirmation\n      raise \"Passwords do not match\"\n    end\n\n    hashed_password = BCrypt::Password.create(password)\n    @user.update_attributes(password: hashed_password)\n\n    { success: true }\n  rescue => e\n    { error: e.message }\n  end\nend\n```\nThis class takes a `User` object as an argument, and has a method called `reset_password`. This method takes two arguments: the new password and its confirmation.\n\nHere's how it works:\n\n1. It checks if the password and its confirmation match.\n2. If they do not match, it raises an error.\n3. If they do match, it uses `BCrypt::Password.create` to create a hashed version of the password.\n4. It then updates the user's password with the new hashed password.\n\nTo use this class, you'll need to have a `User` model that has a `password_digest` attribute (which is used by the `bcrypt` gem). Here's an example using Rails:\n```ruby\nclass User < ApplicationRecord\n  attr_accessor :password\n\n  validates :password, presence: true, length: { minimum: 8 }\n  validates_confirmation_of :password\n\n  def password=(new_password)\n    self.password_digest = BCrypt::Password.create(new_password) if new_password.present?\n  end\nend\n```\nNow you can use the `PasswordReset` class like this:\n```ruby\nuser = User.find(123)\nresetter = PasswordReset.new(user)\n\nbegin\n  result = resetter.reset_password('newpassword', 'newpassword')\n  puts \"Success!\"\nrescue => e\n  puts \"Error: #{e.message}\"\nend\n```\nThis will attempt to reset the user's password with the new value `'newpassword'`. If successful, it will output `\"Success!\"`.\n\n**Remember**: This is a very basic example. In a real-world application, you would want to add additional security measures such as:\n\n* Email verification (to prevent brute-force attacks)\n* Rate limiting (to prevent excessive login attempts)\n* Salting and pepper-based hashing\n* Additional validation and sanitization of user input\n\nPlease keep in mind that this is just an example, and you should always use proper error handling and security practices when implementing password reset functionality.", "code_blocks": ["```ruby\ngem 'bcrypt', '~> 3.1.7'\n```", "```ruby\nrequire 'bcrypt'\n\nclass PasswordReset\n  def initialize(user)\n    @user = user\n  end\n\n  def reset_password(password, confirmation)\n    if password != confirmation\n      raise \"Passwords do not match\"\n    end\n\n    hashed_password = BCrypt::Password.create(password)\n    @user.update_attributes(password: hashed_password)\n\n    { success: true }\n  rescue => e\n    { error: e.message }\n  end\nend\n```", "```ruby\nclass User < ApplicationRecord\n  attr_accessor :password\n\n  validates :password, presence: true, length: { minimum: 8 }\n  validates_confirmation_of :password\n\n  def password=(new_password)\n    self.password_digest = BCrypt::Password.create(new_password) if new_password.present?\n  end\nend\n```", "```ruby\nuser = User.find(123)\nresetter = PasswordReset.new(user)\n\nbegin\n  result = resetter.reset_password('newpassword', 'newpassword')\n  puts \"Success!\"\nrescue => e\n  puts \"Error: #{e.message}\"\nend\n```"]}
{"prompt": "Implement a CORS Policy using ruby", "llm_output": "**CORS (Cross-Origin Resource Sharing) Policy in Ruby**\n===========================================================\n\nHere's an example of how to implement a simple CORS policy using Ruby and the Rack framework.\n\n### Step 1: Install the `rack-cors` gem\n\nAdd the following line to your Gemfile:\n```ruby\ngem 'rack-cors'\n```\nThen run `bundle install`.\n\n### Step 2: Configure CORS in your application\n\nCreate a new file called `config/initializers/cors.rb`. This will be used to configure CORS for your entire application.\n```ruby\n# config/initializers/cors.rb\n\nmodule RackCorsConfig\n  def self.included(app)\n    app.config.middleware.use Rack::Cors do\n      allow do\n        origins '*'\n        resource '/api/*', headers: :any, methods: [:get, :post, :put, :delete]\n      end\n    end\n  end\nend\n```\nThis configuration allows all origins to make requests to any endpoint starting with `/api/`, using any HTTP method and allowing any headers.\n\n### Step 3: Enable CORS in your application\n\nIn your `config/application.rb` file, include the `RackCorsConfig` module:\n```ruby\n# config/application.rb\n\nmodule YourApp\n  class Application < Rails::Application\n    config.middleware.insert_before 0, RackCorsConfig\n  end\nend\n```\nThis will enable CORS for all requests to your application.\n\n### Example Use Cases\n\nHere are a few examples of how you can use this configuration:\n\n* Allow only specific origins:\n```ruby\nmodule RackCorsConfig\n  def self.included(app)\n    app.config.middleware.use Rack::Cors do\n      allow do\n        origins 'https://example.com'\n        resource '/api/*', headers: :any, methods: [:get, :post, :put, :delete]\n      end\n    end\n  end\nend\n```\n* Allow specific HTTP methods and headers:\n```ruby\nmodule RackCorsConfig\n  def self.included(app)\n    app.config.middleware.use Rack::Cors do\n      allow do\n        origins '*'\n        resource '/api/*', headers: :any, methods: [:get]\n      end\n    end\n  end\nend\n```\nRemember to adjust the configuration according to your application's specific needs.\n\n### API Documentation\n\nHere are some additional options you can use in the `Rack::Cors` block:\n\n* `allow do`: Define the allowed origins and resources.\n\t+ `origins`: A string or array of strings specifying the allowed origins (e.g. `'https://example.com'`, `['https://example.com', 'https://example2.com']`).\n\t+ `resource`: A string or array of strings specifying the allowed resources (e.g. `'/api/*'`, `['/api/*', '/admin/*']`).\n* `headers`: Specify which headers are allowed:\n\t+ `:any`: Allow all headers.\n\t+ `[:accept, :content-type]`: Allow only the specified headers.\n* `methods`: Specify which HTTP methods are allowed:\n\t+ `[:get, :post, :put, :delete]`: Allow GET, POST, PUT, and DELETE requests.\n\nNote that this is a basic example of how to implement CORS using Ruby. Depending on your specific use case, you may need to adjust the configuration accordingly.", "code_blocks": ["```ruby\ngem 'rack-cors'\n```", "```ruby\n# config/initializers/cors.rb\n\nmodule RackCorsConfig\n  def self.included(app)\n    app.config.middleware.use Rack::Cors do\n      allow do\n        origins '*'\n        resource '/api/*', headers: :any, methods: [:get, :post, :put, :delete]\n      end\n    end\n  end\nend\n```", "```ruby\n# config/application.rb\n\nmodule YourApp\n  class Application < Rails::Application\n    config.middleware.insert_before 0, RackCorsConfig\n  end\nend\n```", "```ruby\nmodule RackCorsConfig\n  def self.included(app)\n    app.config.middleware.use Rack::Cors do\n      allow do\n        origins 'https://example.com'\n        resource '/api/*', headers: :any, methods: [:get, :post, :put, :delete]\n      end\n    end\n  end\nend\n```", "```ruby\nmodule RackCorsConfig\n  def self.included(app)\n    app.config.middleware.use Rack::Cors do\n      allow do\n        origins '*'\n        resource '/api/*', headers: :any, methods: [:get]\n      end\n    end\n  end\nend\n```"]}
