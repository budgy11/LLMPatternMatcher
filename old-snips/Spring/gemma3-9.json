{"prompt": "Implement a CORS Policy using Spring", "llm_output": "```java\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.CorsConfigurationSource;\nimport org.springframework.web.context.annotation.Configuration;\n\n@Configuration\npublic class CorsConfigurationSourceImpl implements CorsConfigurationSource {\n\n    @Override\n    public CorsConfiguration getDefault() {\n        CorsConfiguration config = new CorsConfiguration();\n\n        // Enable all origins by default.  Adjust as needed for security.\n        config.addAllowedOrigin(\"*\");\n\n        // Allow specific headers\n        config.addAllowedHeader(\"*\");\n\n        // Allow all methods\n        config.addAllowedMethod(\"*\");\n\n        // Set maximum age for CORS headers\n        config.setMaxAge(3600); // 1 hour\n\n        return config;\n    }\n}\n```\n\n**Explanation and Key Points:**\n\n1. **`@Configuration`:**  This annotation indicates that this class provides configuration for Spring.\n\n2. **`CorsConfigurationSource` Interface:**  Spring requires this interface to be implemented to provide CORS configuration information to the `RequestContextListener` (though we're using it directly in this example).\n\n3. **`getDefault()` Method:**\n   - This method *must* be implemented to return the CORS configuration.\n   - It's called by Spring to initialize the CORS configuration.\n\n4. **`CorsConfiguration()`:**  Creates a new `CorsConfiguration` object to hold the CORS settings.\n\n5. **`config.addAllowedOrigin(\"*\")`:**\n   - This is the most important part for enabling CORS.\n   - `\"*\"`  specifies that *any* origin (domain) is allowed to access the resource.  **WARNING:** This is the *least* secure option and should be used only for development or testing.\n   - **Production Considerations:**  In production, you should **never** use `\"*\"` in your CORS configuration.  Instead, you should explicitly list the domains that are allowed to access your API.  This greatly reduces the risk of unauthorized access.\n\n6. **`config.addAllowedHeader(\"*\")`:**  Allows all HTTP headers. Again, be cautious and consider restricting this in production.  Common headers you might want to restrict include `Content-Type`, `Authorization`, and potentially others related to security.\n\n7. **`config.addAllowedMethod(\"*\")`:** Allows all HTTP methods (GET, POST, PUT, DELETE, PATCH, OPTIONS, etc.).  Restricting this is highly recommended for production security.\n\n8. **`config.setMaxAge(3600)`:** Sets the maximum age (in seconds) for the `Access-Control-Expose-Headers` and `Access-Control-Max-Age` headers to 3600 seconds (1 hour). This controls how long the browser caches the preflight request (OPTIONS request) results.  A value of 3600 is a common starting point.\n\n**How to Use this Configuration:**\n\n1. **Place the Configuration Class:**  Save this code as `CorsConfigurationSourceImpl.java` (or a similar name) in your Spring project.  Ensure it's in a package that's accessible to your Spring application.\n\n2. **Add the Class to Your Spring Application Context:**  There are several ways to do this:\n\n   * **`@Configuration` Class (Best Practice):**  If you're using Spring Boot, this is the preferred way. Spring automatically picks up any `@Configuration` classes in your project.  The `@Configuration` annotation tells Spring to load and execute this class.\n\n   * **`@Bean` Annotation:** You could also declare this class as a Spring bean:\n\n     ```java\n     @Configuration\n     public class AppConfig {\n         @Bean\n         public CorsConfigurationSource corsConfigurationSource() {\n             return new CorsConfigurationSourceImpl();\n         }\n     }\n     ```\n\n3. **Configure Your Controller:**  You now need to tell your Spring controllers how to use the CORS configuration.  There are two main approaches:\n\n   * **Using `RequestContextListener` (Deprecated - don't use in new projects):**  *This is not recommended for new Spring projects.*  The `RequestContextListener` is deprecated.\n\n   * **Using a `@CrossOrigin` Annotation (Recommended):**\n      This is the preferred and simpler approach. You add the `@CrossOrigin` annotation to your controller method or class.\n\n      ```java\n      @RestController\n      @CrossOrigin // Apply CORS configuration to this controller\n      public class MyController {\n\n          @GetMapping(\"/data\")\n          public String getData() {\n              // Your logic here\n              return \"Data from API\";\n          }\n      }\n      ```\n\n      By default, the `@CrossOrigin` annotation will use the CORS configuration you defined in `CorsConfigurationSourceImpl`.  You can customize the `@CrossOrigin` annotation to override the defaults.  For example:\n\n      ```java\n      @RestController\n      @CrossOrigin(origins = [\"https://example.com\", \"https://anotherdomain.com\"], allowedHeaders = \"*\", allowedMethods = \"*\")\n      public class MyController {\n          // ...\n      }\n      ```\n\n**Security Considerations and Best Practices:**\n\n* **Restrict Origins:** *Always* restrict the `origins` parameter in the `@CrossOrigin` annotation or in the `CorsConfiguration` to only the domains that need to access your API. This is the most important security measure.\n\n* **Restrict Headers:**  Carefully consider which headers you allow.  The default settings often allow too much access.  Only allow the headers that are absolutely necessary for your application.\n\n* **Restrict Methods:**  Restrict the allowed HTTP methods.\n\n* **Content Security Policy (CSP):**  CORS is a client-side mechanism.  It\u2019s often used in conjunction with a strong Content Security Policy (CSP) in your web server configuration to provide an additional layer of defense.\n\n* **Regularly Review:**  CORS configurations should be regularly reviewed and updated as your application evolves.\n\n**Example of a More Secure Configuration (Production):**\n\n```java\n@RestController\n@CrossOrigin(origins = [\"https://your-trusted-domain.com\"], allowedHeaders = [\"Content-Type\", \"Authorization\"], allowedMethods = {\"GET\", \"POST\"})\npublic class MyController {\n    // ...\n}\n```\n\nThis example allows only requests from `https://your-trusted-domain.com`, only allows the `Content-Type` and `Authorization` headers, and only allows GET and POST methods.  Adapt this to your specific needs, but always prioritize restricting access as much as possible.\n", "code_blocks": ["```java\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.CorsConfigurationSource;\nimport org.springframework.web.context.annotation.Configuration;\n\n@Configuration\npublic class CorsConfigurationSourceImpl implements CorsConfigurationSource {\n\n    @Override\n    public CorsConfiguration getDefault() {\n        CorsConfiguration config = new CorsConfiguration();\n\n        // Enable all origins by default.  Adjust as needed for security.\n        config.addAllowedOrigin(\"*\");\n\n        // Allow specific headers\n        config.addAllowedHeader(\"*\");\n\n        // Allow all methods\n        config.addAllowedMethod(\"*\");\n\n        // Set maximum age for CORS headers\n        config.setMaxAge(3600); // 1 hour\n\n        return config;\n    }\n}\n```", "```java\n     @Configuration\n     public class AppConfig {\n         @Bean\n         public CorsConfigurationSource corsConfigurationSource() {\n             return new CorsConfigurationSourceImpl();\n         }\n     }\n     ```\n\n3. **Configure Your Controller:**  You now need to tell your Spring controllers how to use the CORS configuration.  There are two main approaches:\n\n   * **Using `RequestContextListener` (Deprecated - don't use in new projects):**  *This is not recommended for new Spring projects.*  The `RequestContextListener` is deprecated.\n\n   * **Using a `@CrossOrigin` Annotation (Recommended):**\n      This is the preferred and simpler approach. You add the `@CrossOrigin` annotation to your controller method or class.\n\n      ```java\n      @RestController\n      @CrossOrigin // Apply CORS configuration to this controller\n      public class MyController {\n\n          @GetMapping(\"/data\")\n          public String getData() {\n              // Your logic here\n              return \"Data from API\";\n          }\n      }\n      ```\n\n      By default, the `@CrossOrigin` annotation will use the CORS configuration you defined in `CorsConfigurationSourceImpl`.  You can customize the `@CrossOrigin` annotation to override the defaults.  For example:\n\n      ```java\n      @RestController\n      @CrossOrigin(origins = [\"https://example.com\", \"https://anotherdomain.com\"], allowedHeaders = \"*\", allowedMethods = \"*\")\n      public class MyController {\n          // ...\n      }\n      ```\n\n**Security Considerations and Best Practices:**\n\n* **Restrict Origins:** *Always* restrict the `origins` parameter in the `@CrossOrigin` annotation or in the `CorsConfiguration` to only the domains that need to access your API. This is the most important security measure.\n\n* **Restrict Headers:**  Carefully consider which headers you allow.  The default settings often allow too much access.  Only allow the headers that are absolutely necessary for your application.\n\n* **Restrict Methods:**  Restrict the allowed HTTP methods.\n\n* **Content Security Policy (CSP):**  CORS is a client-side mechanism.  It\u2019s often used in conjunction with a strong Content Security Policy (CSP) in your web server configuration to provide an additional layer of defense.\n\n* **Regularly Review:**  CORS configurations should be regularly reviewed and updated as your application evolves.\n\n**Example of a More Secure Configuration (Production):**\n\n```"]}
